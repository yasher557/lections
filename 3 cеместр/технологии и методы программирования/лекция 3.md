#2024/10/07
# концепции ООП

### инкапсуляция

==Инкапсуляция== защищает данные объекта от неправильных значений и гарантирует их корректную модификацию.

``` java
public class Person {
    // Поля с модификатором private
    private String name;
    private int age;
    
    // Конструктор
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // Геттер для поля name
    public String getName() {
        return name;
    }
    
    // Сеттер для поля name
    public void setName(String name) {
        this.name = name;
    }
    
    // Геттер для поля age
    public int getAge() {
        return age;
    }
    
    // Сеттер для поля age
    public void setAge(int age) {
        if (age > 0) {  // Добавляем валидацию
            this.age = age;
        }
    }
    
    // Метод, который выводит информацию о человеке
    public void showInfo() {
        System.out.println("Имя: " + name + ", Возраст: " + age);
    }
}
```
 
 ==Внешнее представление объекта== — описание того, что объект содержит и как взаимодействует с другими объектами. ==С внешней точки зрения, объект== представляет собой инкапсулируемую сущность и представляет конкретный набор по взаимодействию с ним. Эти услуги определяют интерфейсы объекта. Один объект может использовать другой с помощью услуг, которые он предоставляет.

Клиент объекта может потребовать от него услуги (вызывать методами), но не должен знать о том, как эти услуги осуществляются. Наша задача — сделать трудным или невозможным для клиента получать доступ к переменным объекта напрямую.

Инкапсулированный объект можно рассматривать как чёрный ящик — его внутренняя работа скрыта от людей. Клиент вызывает методы интерфейса объекта, которые управляют данными экземпляров класса.

Инкапсуляция выполняется при помощи ==модификаторов видимости==. "Модификатор" — зарезервированное слово, которое определяет конкретные характеристики методов или данных. Данные методы доступны внутри класса. Если метод создан без модификатора, то метод доступен из любого места в программе.

Публичные методы нарушают инкапсуляцию, так как они позволяют пользователи достичь переменных и изменять их напрямую. Поэтому переменные экземпляра не должны быть объявлены общедоступными. Вполне допустимо давать константам общественную видимость, что позволяет использовать их вне класса. public константы не нарушают инкапсуляцию, так как хоть пользователь и может получить к ним доступ, но не может изменить значение.

Общедоступные методы с модификатором public также называются ==сервисными или обслуживающими методами==. Метод созданный для оказания помощи сервисному методу, называется поддерживающим методом. Так как поддерживающий метод не предназначен для вызова клиентом, он не должен быть объявлен как общедоступный или public.

|                | public                       | privat                               |
| -------------- | ---------------------------- | ------------------------------------ |
| **переменные** | нарушают инкапсуляцию        | обеспечивают соблюдение инкапсуляции |
| **методы**     | предоставляют услуги клиенту | предоставляют услуги методам         |

``` mermaid
flowchart TB

A([класс\npublic class])
B([поле\nints])
C([метод\npublic myM])
final-->A
final-->B
final-->C
```

### наследование

==Наследование== позволяет создавать новые классы на основе существующих. Новые класс наследник получает все свойства и методы родительского и может добавлять свои собственные или изменять, переопределять поведение унаследованных методов.

``` java
// Базовый класс Animal
public class Animal {
    String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    public void sound() {
        System.out.println("Животное издает звук");
    }
    
    public void showName() {
        System.out.println("Имя животного: " + name);
    }
}

// Класс-наследник Dog, который наследует от Animal
public class Dog extends Animal {
    public Dog(String name) {
        super(name);  // Вызов конструктора родительского класса
    }
    
    @Override
    public void sound() {
        System.out.println("Собака гавкает");
    }
}

// Класс-наследник Cat, который наследует от Animal
public class Cat extends Animal {
    public Cat(String name) {
        super(name);
    }
    
    @Override
    public void sound() {
        System.out.println("Кот мяукает");
    }
}
```

### полиморфизм

==Полиморфизм== — способность объектов разных классов по-разному реагировать на одинаковые вызовы метода. Это достигается когда подклассы переопределяют методы родительского класса. На языке java, полиморфизм позволет использовать один и тот же интерфейс для разных объектов. 

``` java
public class Main {
    public static void main(String[] args) {
        // Полиморфизм через родительский тип
        Animal myAnimal = new Animal("Животное");
        Animal myDog = new Dog("Бобик");
        Animal myCat = new Cat("Мурзик");
        
        // Вызов одного и того же метода для разных объектов
        myAnimal.sound();   // Животное издает звук
        myDog.sound();      // Собака гавкает
        myCat.sound();      // Кот мяукает
    }
}
```


### абстракция

==Абстракция== позволяет выделить общие черты объектов, скрыть детали реализации и показывать только важные аспекты. В абстракции фокус идёт на то что делает объект, а не на то, как это делается. В java абстракция реализуется с помощью абстрактных классов и интерфейсов.

==Абстрактный класс== — это класс, который не может быть создан напрямую как объект. Он может содержать как абстрактные методы (без реализации), так и обычные (с реализацией). Абстрактные классы служат для того, чтобы другие классы могли наследовать и реализовывать конкретное поведение.

``` java
// Абстрактный класс Animal
public abstract class Animal {
    String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    // Абстрактный метод (без реализации)
    public abstract void sound();
    
    // Обычный метод
    public void showName() {
        System.out.println("Имя животного: " + name);
    }
}

// Класс Dog реализует абстрактный метод sound
public class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }
    
    @Override
    public void sound() {
        System.out.println("Собака гавкает");
    }
}

// Класс Cat реализует абстрактный метод sound
public class Cat extends Animal {
    public Cat(String name) {
        super(name);
    }
    
    @Override
    public void sound() {
        System.out.println("Кот мяукает");
    }
}
```

### интерфейс

==Интерфейс== — это так называемый "контракт", который класс может реализовать. Он задаёт что должен делать класс, но не содержит конкретной реализации методов.

В интерфейсах все методы по умолчанию абстрактные и не имеют тела, а все поля по умолчанию public static field. Интерфейсы полезны, когда необходимо обеспечить, чтобы разные классы реализовали одинаковые наборы методов, но с разной логикой.

``` java 
// Интерфейс AnimalBehavior
public interface AnimalBehavior {
    void sound();  // метод без реализации
    void move();   // метод без реализации
}

// Класс Dog реализует интерфейс AnimalBehavior
public class Dog implements AnimalBehavior {
    @Override
    public void sound() {
        System.out.println("Собака гавкает");
    }
    
    @Override
    public void move() {
        System.out.println("Собака бежит");
    }
}

// Класс Bird реализует интерфейс AnimalBehavior
public class Bird implements AnimalBehavior {
    @Override
    public void sound() {
        System.out.println("Птица поёт");
    }
    
    @Override
    public void move() {
        System.out.println("Птица летит");
    }
}
```

### отличия абстрактного и обычного метода

Абстрактный класс может содержать как абстрактные, так и обычные методы с реализацией, а интерфейсы содержат только абстрактные методы или могут содержать дефолтные методы с реализацией (с java 8).

Класс может наследовать только один абстрактный класс, но реализовать несколько интерфейсов. В абстрактном классе могут быть поля с различными уровнями доступа, тогда как в интерфейсы все поля являются public static final.

Интерфейсы позволяют реализовать множественное наследование, так как класс может реализовывать сразу несколько интерфейсов.

``` java

// Интерфейс Flyable
public interface Flyable {
    void fly();
}

// Интерфейс Runnable
public interface Runnable {
    void run();
}

// Класс SuperHero реализует оба интерфейса
public class SuperHero implements Flyable, Runnable {
    @Override
    public void fly() {
        System.out.println("Супергерой летает");
    }
    
    @Override
    public void run() {
        System.out.println("Супергерой бежит");
    }
}
```

### вывод

- Инкапсуляция защищает данные от некорректного доступа.

- Наследование позволяет создавать классы на основе существующих и повторно использовать код.

- Полиморфизм обеспечивает доступ, позволяет методам вести себя по-разному, в зависимости от того, на каком объекте они вызываются

- абстракция скрывает детали реализации, мы сосредотачивается на том что делает объект, а не как. Всё достигается через абстрактные классы и интерфейсы

- интерфейсы задают контракты для классов, позволяя реализовывать один и тот же набор методов для разных классов. Интерфейсы повышают гибкость программы.

Данные концепции позволяют структурировать код и сделать его более поддерживаемым.
